package edu.msudenver.gdejohn.poker;

import static com.google.common.base.Functions.constant;
import static com.google.common.base.Functions.identity;
import static com.google.common.collect.ImmutableList.copyOf;
import static java.lang.Math.ceil;
import static java.util.Collections.unmodifiableSet;
import static java.util.stream.IntStream.range;

import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.collect.UnmodifiableIterator;

/**
 * A lazy enumeration of all k-combinations of a given set.
 * 
 * Combinations are generated lexicographically based on the order in which the
 * elements of the set are produced by the set's iterator.
 *
 * @author Griffin DeJohn
 *
 * @param <E> The type of the elements of the given set.
 */
public class Combinations<E> implements Iterable<Set<E>> {
	/**
	 * The elements of the given set.
	 */
	private final List<E> elements;
	
	/**
	 * The size of the given set.
	 */
	private final int n;
	
	/**
	 * The size of the combinations.
	 */
	private final int k;
	
	private final Supplier<Set<E>> supplier;
	
	/**
	 * Applied to each combination generated by the iterator.
	 */
	private final Function<? super Set<E>, Set<E>> function;
	
	private Combinations(Set<E> from, int k, Supplier<Set<E>> supplier, Function<? super Set<E>, Set<E>> processCombination) {
		elements = copyOf(from);
		n = elements.size();
		this.k = k;
		this.supplier = supplier;
		this.function = processCombination;
	}
	
	public static <T> Combinations<T> choose(Set<T> from, int k, Supplier<Set<T>> supplier) {
		return new Combinations<>(from, k, supplier, identity());
	}
	
	public static <T> Combinations<T> choose(Set<T> from, final int k) {
		return choose(from, k, () -> new LinkedHashSet<T>((int) ceil(k / 0.75)));
	}
	
	public static <T> Combinations<T> chooseInPlace(Set<T> from, int k, final Set<T> combination) {
		Supplier<Set<T>> supplierConstant = new Supplier<Set<T>>() {
			@Override
			public Set<T> get() {
				combination.clear();
				return combination;
			}
		};
		return new Combinations<>(from, k, supplierConstant, constant(unmodifiableSet(combination)));
	}
	
	public static <T> Combinations<T> chooseInPlace(Set<T> from, int k) {
		return chooseInPlace(from, k, new LinkedHashSet<T>((int) ceil(k / 0.75)));
	}
	
	public static <T extends Enum<T>> Combinations<T> choose(Class<T> type, Set<T> from, int k) {
		return chooseInPlace(from, k, EnumSet.noneOf(type));
	}
	
	public static <T extends Enum<T>> Combinations<T> choose(Class<T> type, int k) {
		return choose(type, (Set<T>) EnumSet.allOf(type), k);
	}
	
	public Iterator<Set<E>> iterator() {
		final int[] indices = range(0, k).toArray();
		return new UnmodifiableIterator<Set<E>>() {
			private boolean hasNext = true;
			
			@Override
			public boolean hasNext() {
				return hasNext;
			}
			
			@Override
			public Set<E> next() {
				if (!hasNext) {
					throw new NoSuchElementException();
				}
				Set<E> combination = supplier.get();
				for (int index : indices) {
					combination.add(elements.get(index));
				}
                int i = k - 1;
                while (i >= 0 && indices[i] == n - k + i) {
                    i--;
                }
                if (i < 0) {
                    hasNext = false;
                }
                else {
					indices[i]++;
					for (int j = i; j < k; j++) {
						indices[j] = indices[i] + j - i;
					}
				}
				return function.apply(combination);
			}
		};
	}
	
	public static void main(String[] args) {
	    java.util.SortedSet<Integer> set = new java.util.TreeSet<>(java.util.Arrays.asList(0, 1, 2, 3, 4, 5, 6));
	    for (Set<Integer> combination : choose(set, 3)) {
	        java.util.NavigableSet<Integer> complement = new java.util.TreeSet<>(set);
	        complement.removeAll(combination);
	        System.out.println(combination.toString() + " - " + complement.toString());
	    }
	}
}
